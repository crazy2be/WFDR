#!/usr/bin/env python
import os
import sys
import math
import subprocess

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = "\033[1m"

    def disable(self):
        self.HEADER = ''
        self.OKBLUE = ''
        self.OKGREEN = ''
        self.WARNING = ''
        self.FAIL = ''
        self.ENDC = ''

class ArgumentParser:
	__parsedargs__ = {}
	__givenargs__ = {}
	def AddFlag(self, name, help):
		item = {}
		item['help'] = help
		item['type'] = bool
		item['default'] = False
		self.__givenargs__[name] = item
		
	def __argname__(self, arg):
		return arg.replace("-", "")
		
	def __isarg__(self, name):
		for k, v in self.__givenargs__.iteritems():
			if k == name:
				return True
		return False
		
	def __requiresval__(self, name):
		if self.__givenargs__[name]['type'] == bool:
			return False
		return True
		
	def Parse(self):
		parsingArg = False
		for i, arg in enumerate(sys.argv[1:]):
			name = self.__argname__(arg)
			if self.__isarg__(name):
				if parsingArg:
					raise Exception("Expected value, got another argument")
				if self.__requiresval__(name):
					parsingArg = True
				else:
					self.__parsedargs__[name] = True
			else:
				if not parsingArg:
					raise Exception("Expected argument, got another value")
				self.__parsedargs__[self.__argname(sys.argv[i-1])] = sys.argv[i]
		
		for k, v in self.__givenargs__.iteritems():
			if k not in self.__parsedargs__:
				self.__parsedargs__[k] = v['default']

		return self.__parsedargs__
				
	def __getitem__(self, name):
		return self.__arr__[name]

def header1(text):
	rows, columns = os.popen('stty size', 'r').read().split()
	
	divider = "+"
	for i in range(int(columns)-2):
		divider += "-"
	divider += "+"
	padding = ""
	paddinglen = (float(columns)-(2+len(text)))
	extrapad = ""
	if paddinglen % 2:
		extrapad = " "
	for i in range(int(paddinglen/2)):
		padding += " "
	print bcolors.OKGREEN + divider
	print "|" + padding + extrapad + text + padding + "|"
	print divider + bcolors.ENDC

def header2(text):
	print
	print bcolors.BOLD + bcolors.OKGREEN + "==[ " + text + " ]==" + bcolors.ENDC
	
def step(text):
	print bcolors.OKBLUE + "[...] " + text + bcolors.ENDC
	
def run(cmd, message):
	proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	stdout, stderr = proc.communicate()
	if proc.returncode:
		print bcolors.FAIL + "Failed to run command {0}, exit status {1}! Below is the output:".format(cmd, proc.returncode) + bcolors.ENDC
		print stdout
		print stderr
		print bcolors.FAIL + message + bcolors.ENDC
	return proc.returncode

# Check args
parser = ArgumentParser()
parser.AddFlag('update', help="Update all goinstalled packages before the build process. Might be helpful if you are getting build errors.")
parser.AddFlag('clean', help="Rather than building, clean all files from the build. Comparable to running make clean for the framework and each module.")

args = parser.Parse()

# First, install everything required
step("Fetching required packages with goinstall")

f = open('framework/src/goinstalls')
for line in f:
	cmd = "goinstall"
	if args['update']:
		cmd += " -u"
	if args['clean']:
		cmd += ' -clean'
	if run(cmd+' '+line, "Failed to goinstall package!"):
		sys.exit(1)


os.chdir('framework/src')

if args['clean']:
	step("Cleaning existing framework pacakges and commands")
	if run('gomake clean', 'Cleaning existing packages failed!'):
		print "Continuing happily..."

# Next, compile framework packages and commands
step("Compiling framework packages and commands")

if run('gomake', "Build failed :("):
	sys.exit(1)

os.chdir('../..')

# Finally, compile the actual modules
step("Compiling modules")

wfdrcmd = 'compile'
if args['clean']:
	wfdrcmd = 'recompile'

if run('wfdr '+wfdrcmd+' all', "Attempting to "+wfdrcmd+" modules failed"):
	sys.exit(1)
	#print "Because it might be a module you don't care about, we're continuing happily :)"
	#print "Although you might want to look into the issue..."


header2("DONE!")
print "Framework has been built! To run it, start the daemon in one terminal using wfdr-deamon [sic], and then control modules using the wfdr command."
print "wfdr start <modulename> starts a module, wfdr stop <modulename> stops, etc. Run wfdr with no arguments to see usage."